#pragma config(Motor,  motorA,          motorDireita,  tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  motorB,          motorEsquerda, tmotorNXT, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*
													Observacoes
	- As palavras estao sem acentuacao por conta da codificacao dos caracteres do RobotC.
	- "Click's", segundo o RobotC, eh igual a quantidade de passos da contagem do encoder.

*/



/* Variaveis constantes */
#define VELOCIDADE 30
#define GRAU 3.16
#define DIAMETRO 17.59291886

																	/* Declaracao das funcoes */
void girar(int graus, int lado); // Gira o robo a quantidade de graus definidos para o lado escolhido,
																// 0 - Direita ou 1 - Esquerda.
int converterClicks(int graus); // Converte a quantidade de graus para a quantidade de "click's" do encoder.
void mover(float distancia); // Move-se para frente a distancia em centimetros passada.
																	/* Funcoes */

task main(){
	girar(90, 0);
	mover(30);
	girar(90, 0);
	mover(30);
	girar(90, 0);
	mover(30);
	girar(90, 0);
	mover(30);
}

/*
* Gira a quantidade de graus para o lado definido. Considera que o movimento dos motores sejam identicos,
* portanto, o encoder que atingir a quantidade de passos necessarios finaliza o movimento.
* @param graus - Quantidade de graus que o robo deve girar.
* @param lado - Determina o lado no qual vai ser feito o movimento, 0 - Direita, 1 - Esquerda.
*/
void girar(int graus, int lado){
	nMotorEncoder[motorDireita] = 0; // Zero a contagem do encoder.
	nMotorEncoder[motorEsquerda] = 0; // Zero a contagem do encoder.
	if(lado != 0 && lado != 1){ // Verifica o lado indicado, para que nao entre em loop infinito.
		return;
		} else {
				while(nMotorEncoder[motorDireita] < converterClicks(graus) && nMotorEncoder[motorEsquerda] < converterClicks(graus)){ // Vai girar a quantidade de graus definida seguindo os dados dos encoders dos motores.
					if(lado == 0){ // Gira para a direita.
						motor[motorDireita] = VELOCIDADE;
						motor[motorEsquerda] = -VELOCIDADE;
						} else if (lado == 1){ // Gira para a esquerda.
						motor[motorDireita] = -VELOCIDADE;
						motor[motorEsquerda] = VELOCIDADE;
					}
				}
				motor[motorEsquerda] = 0;
				motor[motorDireita] = 0;
	}
}

/**
* Converte a quantidade de graus em quantidade de passos do encoder.
* @param grau - Quantidade de graus que o robo deve girar.
* @return inteiro - Quantidade de "click's" do encoder.
*/
int converterClicks(int graus){
	float rotacoes = 0;
	rotacoes = graus * GRAU; // Quantidade de "click's" do encoder em relacao ao angulo.
	return round(rotacoes); // Retorno a quantidade
}

/**
* Move-se a distancia em centimetros para frente.
* @param distancia - Distancia em centimetros.
*/
void mover(float distancia){
	float clicks = (distancia / DIAMETRO) * 360; // Quantidade de click's do encoder.
	int qtnClick = round(clicks); // Transforma em inteiro;
	nMotorEncoder[motorDireita] = 0; // Zero a contagem do encoder.
	nMotorEncoder[motorEsquerda] = 0; // Zero a contagem do encoder.
	while(nMotorEncoder[motorDireita] < qtnClick && nMotorEncoder[motorEsquerda] < qtnClick){ // Vai andar a quantidade de centimetros definida seguindo os dados dos encoders dos motores.
		motor[motorDireita] = VELOCIDADE;
		motor[motorEsquerda] = VELOCIDADE;
	}
	motor[motorDireita] = 0;
	motor[motorEsquerda] = 0;
}
