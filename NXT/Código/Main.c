#pragma config(Motor,  motorA,          motorEsquerda,  tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  motorB,          motorDireita, tmotorNXT, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*
													Observacoes
	- As palavras estao sem acentuacao por conta da codificacao dos caracteres do RobotC.
	- "Click's", segundo o RobotC, eh igual a quantidade de passos da contagem do encoder.
*/

/* Variaveis constantes */
#define VELOCIDADE 60 // Velocidade de locomoçao(giro e movimentos para frente).
#define QTNBR 128 // Determina a quantidade maxima de bytes a serem lidos na recepçao do bluetooth.

																	/* Declaracao das funcoes */
void girar(int qtnClick, int lado); // Gira o robo a quantidade de click's definidos para o lado escolhido,
																// 0 - Direita ou 1 - Esquerda.
void mover(int qtnClick); // Move-se para frente a distancia em centimetros passada.
void configurar(); // Estabelece as configuracoes padroes iniciais.

void checkBTLinkConnected(); // Verificar se existe conexao com a supervisao.

																/* Declaracao das Tasks */
task Receiver(); // Task para receber os dados.
task executarTrajetoria(); // Inicia o movimento seguindo a trajetoria definida.
task msgExecutando(); // Mensagem de aviso de executando trajetoria.

																/* Variaveis */
ubyte *arrayCaminho; // Array com o caminho a ser executado.
int qtnCaminhos = 0; // Identifica a quantidade de caminhos existentes na trajetoria.
bool useArrayCaminho = false; // Identifica se o array de caminhos esta sendo utilizado.
																	/* Funcoes */

task main(){
	configurar(); // Inicializa as configuracoes iniciais basicas para o funcionamento do sistema.
	checkBTLinkConnected(); // Verifica se existe conexao com o supervisor.
	eraseDisplay();
	nxtDisplayCenteredTextLine(3, "Aguardando");
	nxtDisplayCenteredTextLine(4, "Instrucoes");
	StartTask(Receiver); // Inicia a recepcao das instrucoes.
	while(true){}
}

/*
* Gira a quantidade de click's para o lado definido. Considera que o movimento dos motores sejam identicos,
* portanto, o encoder que atingir a quantidade de passos necessarios finaliza o movimento.
* @param qtnClick - Quantidade de click's que o robo deve girar.
* @param lado - Determina o lado no qual vai ser feito o movimento, 0 - Direita, 1 - Esquerda.
*/
void girar(int qtnClick, int lado){
	nMotorEncoder[motorA] = 0; // Zero a contagem do encoder.
	nSyncedTurnRatio = -100; // Quando eu aplicar uma determinada velocidade no motor principal o escravo vai assumir a velocidade oposta.
	if(lado != 0 && lado != 1){ // Verifica o lado indicado, para que nao entre em loop infinito.
		return;
		} else {
		nMotorEncoderTarget[motorA] = qtnClick;
		if(lado == 0){ // Gira para a direita.
			motor[motorA] = VELOCIDADE;
			} else if (lado == 1){ // Gira para a esquerda.
			motor[motorA] = -VELOCIDADE;
		}
	}
	while(nMotorRunState[motorA] != runStateIdle)  // Enquanto o motor A estiver movendo-se:
	{
		// Nao continua
	}
	motor[motorA] = 0; // Para o motor.
}

/**
* Move-se a distancia quantidade de click's do encoder para frente.
* @param qtnClick - Quantidade de click's do encoder.
*/
void mover(int qtnClick){
	nSyncedTurnRatio = 100; // Quando o motor principal assumir uma velocidade o escravo vai mover-se na mesma velocidade.
	nMotorEncoder[motorA] = 0; // Zero a contagem do encoder.
	nMotorEncoderTarget[motorA] = qtnClick;        // Determino o valor alvo do encoder do motor A, em seguida ele para-o.
	motor[motorA] = VELOCIDADE;                       // Motor A mover na velocidade determinada.
	while(nMotorRunState[motorA] != runStateIdle)  // Enquanto o motor A estiver movendo-se:
	{
		// Nao continua
	}
		motor[motorA] = 0; // Para o motor.
}

/**
* Define as conficuracoes iniciais do robo.
*/
void configurar(){
	bFloatDuringInactiveMotorPWM = false; // Determina a forma de parada dos motores.
	nSyncedMotors = synchAB; // Faz com que o motor A seja o principal e o B escravo dele.
	nMaxRegulatedSpeedNxt = 750; // Velocidade maxima do ajuste de velocidade dos encoders 750 click's por segundo.
}

//Funcao pra conectar com a supervisao, que deve ja estar executando.
void checkBTLinkConnected(){
  while(true){
		if (nBTCurrentStreamIndex >= 0)
			break; // An existing Bluetooth connection is present.
  }
	setBluetoothRawDataMode();
	while (!bBTRawMode){
		// Wait for Bluecore to enter raw data mode
		wait1Msec(50);
	}
}

																	/* Tasks */
/*
* Task de recebimento de dados do supervisor. Responsavel pela identificacao da array de movimento e
* inicio do trajeto.
*/
task Receiver(){
	int nNumBytesRead = 0;
	ubyte BytesRead[QTNBR];
	while(true){
		nNumBytesRead = nxtReadRawBluetooth(&BytesRead[0], QTNBR);
		if(nNumBytesRead == 0){// Se nao receber nada, então espero 10Msec.
			wait1Msec(10);
			} else if (BytesRead[0] == '#' && useArrayCaminho == false){ // Caso tenha lido uma informação com o formato do protocolo
			eraseDisplay();
			nxtDisplayString(0, "Lido : %d byte(s)", nNumBytesRead);
			PlaySound(soundBeepBeep);
			qtnCaminhos = (int)BytesRead[1];// Pega a quantidade de retas que o caminho possue.
			arrayCaminho = &BytesRead+2; // Pega o caminho a ser executado.
			nxtDisplayCenteredTextLine(2, "Cam : %d", qtnCaminhos);
			nxtDisplayCenteredTextLine(3, "O caminho");
			nxtDisplayCenteredTextLine(4, "possue");
			nxtDisplayCenteredTextLine(5, "%d reta(s)", qtnCaminhos);
			} else if(BytesRead[0] == '@' && useArrayCaminho == false){ // Inicia o movimento caso exista trajetoria
			StartTask(executarTrajetoria);
			} else if(BytesRead[0] == 0xFF && useArrayCaminho == true){ // Encerra a movimentacao
			StopTask(executarTrajetoria);
			motor[motorA] = 0;
			useArrayCaminho = false;
			StopTask(msgExecutando);
			nxtDisplayCenteredTextLine(3, "Aguardando");
			nxtDisplayCenteredTextLine(4, "Instrucoes");
			} else { // Caso tenha lido algo e nao se encaixa com o padrao do protocolo.
			PlaySound(soundDownwardTones);
		}

	}
}

/*
* Executa a trajetoria armazenada no "arrayCaminho".
*/
task executarTrajetoria(){
	if(qtnCaminhos <= 0){
		eraseDisplay();
		nxtDisplayCenteredTextLine(2, "Nao existe");
		nxtDisplayCenteredTextLine(3, "trajetoria");
		nxtDisplayCenteredTextLine(4, "registrada.");
	} else {
		int i = 0; // Variavel para controle da posicao de leitura do array.
		int j = 0; // Variavel controle, armazena a quantidade de execucoes do laco while.
		int movimento = 0; // Armazena a quantidade de click's do encoder.
		int grau = 0; // Grau no qual sera feito o giro.
		int lado = 0; // Determina o lado no qual o giro sera feito.
		useArrayCaminho= true;// Determino que o array esta em uso, portanto, um novo caminho sera desconsiderado.
		StartTask(msgExecutando); // Exibe a mensagem de "Executando Movimento".
		while(arrayCaminho [i] != 0xFF ){ // Verifica se tem algum passo para ser executado.
			movimento = arrayCaminho[i]; // Pega a quantidade de ciclos da roda
			movimento *= 360; // Multiplica a quantidade de giros da roda pela quantidade de click's do encoder em uma volta completa.
			movimento += arrayCaminho[++i]; // Soma com a quantidade de click's, menor que 360.
			mover(movimento);
			if(arrayCaminho [++i] == 0xFF){// Caso o movimento nao finalize com giro.
				break;
			} else { // Caso nao seja fim do movimento.
				grau = arrayCaminho[i++];
				lado = arrayCaminho[i++];
				girar(grau, lado); // Gira a quantidade de graus para o lado determinado.
			}
		}
		StopTask(msgExecutando);
		eraseDisplay();
		nxtDisplayCenteredTextLine(3, "Aguardando");
		nxtDisplayCenteredTextLine(4, "Instrucoes");
		useArrayCaminho = false; // Com o fim do caminho a variavel eh alterada.
	}
}

/**
* Exibe a mensagem "Executando Trajetoria" piscando a cada segundo.
*/
task msgExecutando(){
	eraseDisplay();
	while(true){
		nxtDisplayCenteredTextLine(3, "Executando");
		nxtDisplayCenteredTextLine(4, "Trajetoria");
		wait10Msec(100);
		eraseDisplay();
		wait10Msec(100);
	}
}
